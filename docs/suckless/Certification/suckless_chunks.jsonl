{"id": "module-01-01", "source": "Module 1: Philosophy of Minimalism", "role": "instructor", "instruction": "Summarize the Suckless software philosophy in one paragraph.", "input": "The Suckless project rejects bloated software. It prefers minimal, source-configured tools aligned with the Unix philosophy.", "output": "Suckless philosophy promotes minimalist software built for clarity, efficiency, and user control. Each tool solves one problem well, favoring static configuration and composability over features and plugins."}
{"id": "module-03-02", "source": "Module 3: C Style Guide", "role": "reviewer", "instruction": "Evaluate this snippet's conformance to Suckless C style.", "input": "int main(){int x=0;for(int i=0;i<10;i++){x+=i;}printf(\"%d\",x);}", "output": "Violates Suckless C style. Issues: brace placement, inline declarations, compressed formatting. Use tabs for indentation, place braces on new lines, declare vars at top of block."}
{"id": "module-04-01", "source": "Module 4: Configuration Through Source Code", "role": "instructor", "instruction": "Compare static configuration via header files with dynamic config formats.", "input": "Header: #define FONT \"monospace:size=10\"\nConfig file: config.json", "output": "Header-based config is safer and simpler. It compiles errors early, avoids parser complexity, and keeps the codebase small and readable\u2014key Suckless goals."}
{"id": "notes-02", "source": "notes.txt", "role": "system-analyst", "instruction": "Explain how SucklessCodeGPT achieves composability in script design.", "input": "All scripts return stdout, stderr, and exit codes cleanly. They are designed to be piped or wrapped via POSIX shell.", "output": "Composability is achieved by respecting Unix stream principles. Tools do one job, return clean output, and integrate with shell pipelines and automation frameworks."}
{"id": "optimize-03", "source": "optimize.txt", "role": "performance-engineer", "instruction": "Describe how to baseline a program\u2019s performance using Suckless methods.", "input": "Use `time`, `perf`, `valgrind`, and record in CSV format. Pin environment (e.g., bash 5.1, gcc 11) for reproducibility.", "output": "Performance baselining starts with consistent environments. Measure with lean tools like `time` and `perf`, store metrics in structured formats, and rerun before tuning begins."}
{"id": "debugger-01", "source": "debugger.txt", "role": "instructor", "instruction": "Explain the purpose of the `adjust_tokens()` function.", "input": "The function calculates complexity by counting code length and key tokens.", "output": "`adjust_tokens()` estimates logical complexity to assign a token budget. It considers length and control keywords to scale debug effort realistically in SucklessGPT."}
